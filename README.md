# Apigee Proxy demonstrating jwt-bearer Token Exchange

This API Proxy bundle demonstrates token exchange - a self-signed JWT for an opaque OAuth
token as decribed by [IETF RFC 7523](https://tools.ietf.org/html/rfc7523).

Think of this as an alternative to the "client credentials" grant type,
which was originally defined in [section 4.4 of IETF RFC
6749](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4).

## Disclaimer

This example is not an official Google product, nor is it part of an official
Google product. It's an example.

## Background

The standard client credentials request-for-token looks like this:

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```

... where the Authorization header contains a base64-encoded form of the client
ID and the client secret, concatenated with a colon (:). If you base64-decode
the above blob (`czZCaGR...`), you get `s6BhdRkqt3:gX1fBat3bV`, which would mean, for this request,
the client ID is `s6BhdRkqt3` and the client secret is `gX1fBat3bV`.

Some security-conscious people judge that this is less than ideal, because there is a secret
transmitted over the network in every request for token. IETF RFC 7523 formally
describes one way to avoid doing that, by relying on public/private key
encryption.  Instead of sending a client id+secret pair, the client sends an
_assertion_ that is signed with the client's private key.  No secret ever crosses the network.


The request for token looks like so:

```
POST /token HTTP/1.1
Host: as.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer
&assertion=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.
eyJpc3Mi[...omitted for brevity...].
J9l-ZhwP[...omitted for brevity...]
```

In the above, the assertion form parameter is a specially-formatted one-time-use
JWT. The client self-signs this token with its _private key_, and then sends it
with the request for an access token. The token dispensary must verify the
signature on the JWT, thereby verifying that the sender possesses the private
key, and then can generate an access token.  In this way, it's a "token
exchange". The grant type is known as "jwt-bearer", and uses the grant type
identifier of `urn:ietf:params:oauth:grant-type:jwt-bearer`.  (The version in the
example request above is simply url-encoded.)

This is the style of token exchange process employed [by Google for service-to-service
invocation](https://developers.google.com/identity/protocols/OAuth2ServiceAccount)
for any of the cloud apis (*.googleapis.com), including Cloud Logging, Vertex AI, BigQuery, Apigee, and so on.  [Google
Assistant](https://developers.google.com/actions/identity/oauth2-assertion-flow)
also uses this flow to obtain tokens from _external_ systems.

This example shows you how you can implement this flow within your Apigee
organization, to allow client apps to authenticate via the more secure jwt-bearer approach.


## Dependencies

The helper scripts used here depend on various unix-ish utilities {npm and node,
sed and tr, jq, openssl}, and also the bash shell. If you want to invoke calls, you need curl.
You can do all the setup and testing without these tools, if you like.


## The Proxy Endpoint

This endpoint handles requests for token exchange. The basepath is `/jwt-bearer-oauth`.

It accepts as input a `POST /jwt-bearer-oauth/token`

with a form-encoded payload (header `Content-Type` must be
`x-www-form-urlencoded`) which includes:

* grant_type = `urn:ietf:params:oauth:grant-type:jwt-bearer`
* assertion = a JWT

The payload of the JWT should look something like this:
```
{
  "aud": "https://www.example.com/jwt-bearer-oauth/token",
  "sub": "api-key-goes-here",
  "iss": "api-key-goes-here",
  "exp": 1549663491,
  "iat": 1549663191
}
```

The JWT must:
* be signed via RS256 or RS384 using the public key belonging to the developer.
* be not expired
* have a maximum lifespan no greater than 300 seconds. (It must have both an iat and an exp claim, and the difference must be less than 300 seconds.)
* have never been previously used to obtain a token.
* have the correct audience (==token endpoint URL) and issuer (==consumer key).

If all these checks pass, then the proxy generates an oauth access token, for
the specified consumer key, and returns it. It has an expiry that you (the proxy
designer) can specify or alter; the requester does not get to choose the expiry
of the opaque oauth token. This token can then be used like any other OAuth
access token generated by Apigee, in subsequent requests for service.


## Why?

One might ask: _Why exchange a JWT for an opaque token? Why not just use the JWT
for every service request?_

The reason to perform a token exchange is to allow fast server-side checking of
access tokens. JWT are (a) large (512 bytes or more), and require time and space to
send over the network, and (b) computationally expensive to parse and verify,
because they use public/private key signatures. On the other hand, an opaque
OAuth token generated by Apigee, is really easy and cheap for a client to
store and transmit (~32 bytes), and easy and fast for Apigee to verify.

Exchanging a JWT for an opaque token allows a faster token transmission, and
faster check of the token on the server side, during many many API requests.

This token exchange - a JWT identifying the service for an opaque oauth token -
is the pattern used by APIs for most public Google services.

You might also ask: _Why not just use a client-credentials grant, as described
in [the OAuth Standard (RFC 6749)](https://tools.ietf.org/html/rfc6749)?_

The reason to rely on a signed JWT in the beginning is to avoid sending secrets
across the network. A client secret is a secret, and in OAuth Client Credentials
grant, the client must send that secret to the server. With the JWT bearer (RFC
7523) grant, the client does not transmit secrets. Instead it transmits a
digital signature which proves that the signer possesses the private key.


## The Token Exchange Logic

Here's how it works:
* In Apigee, there must be a developer entity, an API product, and an app registered for the developer, authorized on the API Product.
* The registered app must have a custom attribute named "public_key", and its contents must be the PEM/PKCS8 encoding of a public key. Replace the newlines with spaces prior to storing the PEM string, but include the beginning and ending stanzas (`-----BEGIN PUBLIC KEY-----` and of course all of the encoded data ).
* The client must generate a JWT, which is signed with the corresponding private key
* The app sends in the JWT to request an access token
* Apigee checks the JWT, and issues the access token if everything is valid

The check for validity involves:
* The issuer must be a valid API Key registered in Apigee. Not expired nor revoked.
* The total lifetime of the JWT must be no longer than 5 minutes.
* The issued-at time must be valid. The not-before-time, if it exists, must be valid.
* The signature is correct.
* The JWT cannot have been used previously.


## Provisioning

There's a provisioning script that helps you create all the things required as
described above. To use it, you need a bash shell, with the following tools on your path:

* curl
* npm and node
* openssl
* jq
* sed and tr

You can use Google Cloud Shell for this purpose; it has all of these pre-requisites.  To get there:
```
 gcloud cloud-shell ssh
```

## The Steps:

1. Once you have your terminal opened, make sure you are signed in:
   ```
   gcloud auth login
   ```
   You may see a message advising you that you are already logged in.
   ```
   You are already authenticated with gcloud when running
   inside the Cloud Shell and so do not need to run this
   command. Do you wish to proceed anyway?

   Do you want to continue (Y/n)?
   ```

   Please ignore that,
   and proceed to logging in again.

2. Set your environment.  Modify the [env.sh](./env.sh) file to set the proper
   values for your purposes.

   Then, source that file
   ```
   source ./env.sh
   ```

3. Set up the Apigee entitites, the developer, the product, and the app.
   ```
   ./setup-apigee-entities.sh
   ```

   This all will take a few moments.

   > You could do all of this yourself by manually fiddling with the Apigee UI to
   > configure all those things.  If you're not clear on how all of those entities all
   > inter-related, you probably DO want to perform the manual configuration, but
   > that's not something this sample will cover.

   As part of its work, this script will create a new RSA keypair and store the
   public key and the private key, separately, in the keys subdirectory. It will
   attach the corresponding public key as a _custom attribute_ to the configured
   application.

   When the script finishes it will show an output like the following:
   ```
   All the Apigee artifacts are successfully deployed.
   Copy/paste the following statement, into your shell:

   export CLIENT_ID="MzZK7SeX086zD...."

   -----------------------------

   To call the API manually, copy/paste the above line to set the variable, and
   then :

     node ./create-self-signed-JWT.js

   With the JWT returned from the above, invoke the token endpoint:

     JWT=ey....copy-paste-from-output-of-above
     curl -i -X POST https://your-host-name/jwt-bearer-oauth/token \
         -d assertion=$JWT -d grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer
   ```

4. Copy/paste the CLIENT\_ID statement from the above, to export it into your environment.
   ```
   export CLIENT_ID="MzZK7SeX...your-client-id-here......."
   ```

5. Create a new self-signed JWT, to use in the request-for-token
   ```
   node ./create-self-signed-JWT.js
   ```

   > Here again, you don't NEED to use this tool to create the JWT.  It's just a convenience.
   > You can use any tool to create the JWT. If you want an interactive experience try
   > [this one](https://dinochiesa.github.io/jwt) . Keep in mind that you need to paste in
   > your private key, the one that the setup script created.  Look in the keys subdirectory.


   The output will include a line like this:
   ```
   [2024/03/26 01:47:37.499] [LOG] token: JWT=eyJhbGciOiJS...
   ```
   Copy/paste the JWT value into your shell, to set the variable:
   ```
   JWT=eyJhbGciOiJS...full-value-here....
   ```

6. Request an access token with that self-signed JWT
   ```
   curl -i -X POST https://${APIGEE_HOST}/jwt-bearer-oauth/token \
         -d assertion=$JWT -d grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer
   ```

   You should see as output, a payload like the following:
   ```
   {
     "access_token": "K0FmSstQI6f4ZB6zs0t9jTIASGcx",
     "issued_at": 1711417959197,
     "expires_in": 1799,
     "api_products": [
       "verify-test-1"
     ],
     "issued": "2024-03-26T01:52:39.197Z",
     "expires": "2024-03-26T02:22:38.197Z"
   }
   ```

## Exploring and Experimenting

1. Use the Google Cloud Console to examine the custom attributes on the app.
   You should see the PEM-encoded public key, for each app.
   With jwt-bearer token exchange, using an RSA algorithm, the app does not use
   the client secret (aka consumer secret).

2. Copy/paste the self-signed JWT into a decoder like [here](https://dinochiesa.github.io/jwt)
   You can view the decoded contents of the header, and the payload.

3. Try to re-submit the same self-signed JWT. You should see a rejection from Apigee. The JWT
   is treated as a one-time use assertion.

4. Enable a Debugsession in the Apigee UI.  Observe the proxy execution in the
   request-for-access-token, for both success cases, and rejections.

5. The token exchange enforces a number of requirements on the self-signed JWT.
   You can observe this enforcement by changing the arguments to the
   `create-self-signed-JWT.js` program.

   ```
   node ./create-self-signed-JWT.js [ARGUMENTS]
   ```
   And then submitting the resulting JWT in the request-for-access-token.

   These are some possibilities, where you should see a rejection in the response.

   | token requirement                        | ARGUMENTS to use  |
   | ---------------------------------------- | ----------------- |
   | aud claim must be token dispensing proxy | `--audience foo`  |
   | lifespan < 300s                          | `--lifespan 600s` |
   | issuer must be client ID                 | `--issuer 600s`   |
   | signed by the appropriate private key    | `--privatekey keys/alternative-key.pem` |

6. Create a new JWT, with a short lifespan:
   ```
   node ./create-self-signed-JWT.js --lifespan 5s
   ```
   ... and then _wait 10 seconds_ while it expires. Then, submit that expired JWT in the request for token:
   ```
   curl -i -X POST https://${APIGEE_HOST}/jwt-bearer-oauth/token \
         -d assertion=$JWT -d grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer
   ```
   You should see an appropriate rejection.


## Clean Up

After you are finished experimenting and exploring, you can remove the
developer, the product, and the app, and the proxies from your organization. To
do that, run the cleanup script:

```
./clean-apigee-entities.sh

```

## Copyright and License

This material is [Copyright (c) 2023-2024 Google, LLC.](NOTICE)
and is licensed under the [Apache 2.0 License](LICENSE).
